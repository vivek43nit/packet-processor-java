/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.geekvivek.serializer.packetprocessor.packet.util;

import com.geekvivek.serializer.packetprocessor.packet.DataPacket;

/**
 * This class has all necessary static methods to handle a packet.
 * @author Vivek
 */
public class DataLibrary {
    
    /**
     * This function will read two byte from data starting from index
     * and convert that into int and returns
     * @param data byte array from which 2 byte is to be read
     * @param index stating index from where reading will be started in data
     * @return int generated by reading 2 byte from data
     */
    public static int twoByteToInt(byte[] data, int index) {
        int t = data[index] & 0x00FF;
        return (t << 8) | (data[index + 1] & 0x00FF);
    }

    /**
     * This function will read four byte from data starting from index
     * and convert that into long and returns
     * @param data byte array from which 4 byte is to be read
     * @param index stating index from where reading will be started in data
     * @return long generated by reading 4 byte from data
     */
    public static long fourByteToLong(byte[] data,int index){
        long t = data[index] & 0x00FF;
        t = (t << 8) | (data[index + 1] & 0x00FF);
        t = (t << 8) | (data[index + 2] & 0x00FF);
        return (t << 8) | (data[index + 3] & 0x00FF);
    }

    /**
     * This function will read eight byte from data starting from index
     * and convert that into long and returns
     * @param data byte array from which 8 byte is to be read
     * @param index stating index from where reading will be started in data
     * @return long generated by reading 8 byte from data
     */
    public static long eightByteToLong(byte[] data,int index){
        long t = data[index] & 0x00FF;
        t = (t << 8) | (data[index + 1] & 0x00FF);
        t = (t << 8) | (data[index + 2] & 0x00FF);
        t = (t << 8) | (data[index + 3] & 0x00FF);
        t = (t << 8) | (data[index + 4] & 0x00FF);
        t = (t << 8) | (data[index + 5] & 0x00FF);
        t = (t << 8) | (data[index + 6] & 0x00FF);
        return (t << 8) | (data[index + 7] & 0x00FF);
    }
    
    /**
     * It will read all eight byte from a long and convert that into byte
     * array and will fill into buffer starting from index offset.
     * @param buffer byte array where the eight bytes will be filled
     * @param offset stating index from where the data will be filled
     * @param val long value to be converted
     */
    public static void setLongLong(byte[] buffer,int offset,long val){
        buffer[offset++] = (byte) ((val >>> 56) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 48) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 40) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 32) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 24) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 16) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 8) & 0x00FF);
        buffer[offset++] = (byte) (val & 0x00FF);
    }

    /**
     * It will read only first four byte from a long and convert that into byte
     * array and will fill into buffer starting from index offset.
     * @param buffer byte array where the four bytes will be filled
     * @param offset stating index from where the data will be filled
     * @param val long value to be converted
     */
    public static void setLong(byte[] buffer,int offset,long val){
        buffer[offset++] = (byte) ((val >>> 24) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 16) & 0x00FF);
        buffer[offset++] = (byte) ((val >>> 8) & 0x00FF);
        buffer[offset++] = (byte) (val & 0x00FF);
    }

    /**
     * It will read only first two byte from a int and convert that into byte
     * array and will fill into buffer starting from index offset.
     * @param buffer byte array where the two bytes will be filled
     * @param offset stating index from where the data will be filled
     * @param val int value to be converted
     */
    public static void setInt(byte[] buffer,int offset,int val){
        buffer[offset++] = (byte) ((val >>> 8) & 0x00FF);
        buffer[offset++] = (byte) (val & 0x00FF);
    }
    
     
    public static long ipToLong(String ipAddress)
    {
        long result = 0;
        if (ipAddress.length() == 0)
        {
            return 0;
        }
        String[] ipAddressInArray = ipAddress.split("\\.");
        for (int i = 3; i >= 0; i--)
        {
            long ip = Long.parseLong(ipAddressInArray[3 - i]);
            //left shifting 24,16,8,0 and bitwise OR
            //1. 192 << 24
            //1. 168 << 16
            //1. 1   << 8
            //1. 2   << 0
            result |= ip << (i * 8);
        }
        return result;
    }
    /*Piyush : funtion to change long to IP*/
    public static String longToIp(long ip)
    {
        return ((ip >> 24) & 0xFF) + "."
                + ((ip >> 16) & 0xFF) + "."
                + ((ip >> 8) & 0xFF) + "."
                + (ip & 0xFF);
    }
    
    public static void createErrorPacket(DataPacket response, int errNum) {
        response.setMessageType(Messages._ERROR);
        response.setInt(Messages.ERROR_CODE, errNum);
    }
}
